<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Timeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: white;
            padding: 20px;
        }

        .timeline-wrapper {
            padding: 20px 0;
        }

        .timeline-container {
            position: relative;
            width: 100%;
            height: 550px;
            margin: 0 auto;
        }

        .timeline-line {
            position: absolute;
            top: 220px;
            left: 1.5%;
            right: 1.5%;
            height: 2px;
            background: #333;
        }

        .quarter {
            position: absolute;
            top: 0;
            height: 100%;
        }

        .quarter-line {
            position: absolute;
            left: 0;
            top: 50px;
            bottom: 50px;
            border-left: 1px dashed #bbb;
        }

        .quarter-label {
            position: absolute;
            top: 235px;
            left: 0;
            transform: translateX(-50%);
            font-size: 12px;
            color: #333;
            white-space: nowrap;
        }

        .marker {
            position: absolute;
            top: 220px;
        }

        .marker-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
            left: -4px;
            top: -3px;
            z-index: 10;
        }

        .marker-stem {
            position: absolute;
            width: 1px;
            background: #333;
            left: 0;
        }

        .marker-stem.above {
            bottom: 5px;
        }

        .marker-stem.below {
            top: 5px;
        }

        .marker-label {
            position: absolute;
            font-size: 11px;
            color: #333;
            white-space: nowrap;
            transform: rotate(-45deg);
            transform-origin: bottom left;
        }

        .marker-label.above {
            left: 2px;
        }

        .marker-label.below {
            left: 2px;
            transform: rotate(45deg);
            transform-origin: top left;
        }

        .marker-comment {
            position: absolute;
            font-size: 9px;
            color: #555;
            max-width: 100px;
            line-height: 1.3;
            text-align: left;
            top: 180px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="timeline-wrapper">
        <div class="timeline-container" id="timeline">
            <div class="timeline-line"></div>
        </div>
    </div>

    <script>
        // Parse CSV and build timeline
        async function loadTimeline() {
            const response = await fetch('models_benchmarks.csv');
            const csvText = await response.text();
            const lines = csvText.trim().split('\n');

            // Find column indices
            const headerRow = parseCSVLine(lines[0]);
            const modelIdx = headerRow.indexOf('Model');
            const orgIdx = headerRow.indexOf('Organisation');
            const dateIdx = headerRow.indexOf('Date');
            const commentsIdx = headerRow.indexOf('Comments');

            // Parse data rows
            const models = [];
            for (let i = 1; i < lines.length; i++) {
                // Handle CSV with potential commas in fields
                const row = parseCSVLine(lines[i]);
                if (row.length > dateIdx) {
                    const dateStr = row[dateIdx];
                    if (dateStr && dateStr.match(/\d+\/\d+\/\d+/)) {
                        const comment = commentsIdx >= 0 && row.length > commentsIdx ? row[commentsIdx] : '';
                        models.push({
                            model: row[modelIdx],
                            org: row[orgIdx],
                            date: dateStr,
                            comment: comment
                        });
                    }
                }
            }

            // Sort by date
            models.sort((a, b) => parseDate(a.date) - parseDate(b.date));

            // Calculate date range for quarters
            const dates = models.map(m => parseDate(m.date));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            // Generate quarters from min to max
            const quarters = generateQuarters(minDate, maxDate);

            // Render timeline
            renderTimeline(quarters, models);
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parseDate(dateStr) {
            const parts = dateStr.split('/');
            const month = parseInt(parts[0]);
            const day = parseInt(parts[1]);
            let year = parseInt(parts[2]);
            if (year < 100) year += 2000;
            return new Date(year, month - 1, day);
        }

        function getQuarter(date) {
            const month = date.getMonth();
            const quarter = Math.floor(month / 3) + 1;
            return { q: quarter, year: date.getFullYear() };
        }

        function generateQuarters(minDate, maxDate) {
            const quarters = [];
            let current = new Date(minDate);
            current.setDate(1);
            current.setMonth(Math.floor(current.getMonth() / 3) * 3);

            while (current <= maxDate) {
                const q = getQuarter(current);
                quarters.push({
                    label: `Q${q.q} ${q.year}`,
                    year: q.year,
                    quarter: q.q,
                    startDate: new Date(current)
                });
                current.setMonth(current.getMonth() + 3);
            }

            // Add one more quarter at the end for spacing
            const q = getQuarter(current);
            quarters.push({
                label: `Q${q.q} ${q.year}`,
                year: q.year,
                quarter: q.q,
                startDate: new Date(current)
            });

            return quarters;
        }

        function getPositionInTimeline(date, quarters) {
            const totalQuarters = quarters.length;
            const firstQuarterStart = quarters[0].startDate;
            const lastQuarterStart = quarters[quarters.length - 1].startDate;

            // Find which quarter this date falls in
            for (let i = 0; i < quarters.length - 1; i++) {
                const qStart = quarters[i].startDate;
                const qEnd = quarters[i + 1].startDate;

                if (date >= qStart && date < qEnd) {
                    // Calculate position within quarter (0-1)
                    const quarterDuration = qEnd - qStart;
                    const posInQuarter = (date - qStart) / quarterDuration;

                    // Calculate overall position (percentage)
                    const quarterWidth = 97 / (totalQuarters);
                    const basePos = 1.9 + (i * quarterWidth);
                    return basePos + (posInQuarter * quarterWidth);
                }
            }

            // Fallback for dates in last quarter
            const lastIdx = quarters.length - 1;
            const quarterWidth = 97 / totalQuarters;
            return 1.9 + (lastIdx * quarterWidth);
        }

        function renderTimeline(quarters, models) {
            const container = document.getElementById('timeline');
            const totalQuarters = quarters.length;
            const quarterWidth = 97 / totalQuarters;

            // Render quarter markers
            quarters.forEach((q, i) => {
                const pos = 1.9 + (i * quarterWidth);
                const quarterDiv = document.createElement('div');
                quarterDiv.className = 'quarter';
                quarterDiv.style.left = `${pos}%`;
                quarterDiv.innerHTML = `
                    <div class="quarter-line"></div>
                    <div class="quarter-label">${q.label}</div>
                `;
                container.appendChild(quarterDiv);
            });

            // Track positions for collision detection
            const usedPositions = [];
            const commentRows = {}; // Track which row each comment should go in

            // Render model markers
            models.forEach((model, idx) => {
                const date = parseDate(model.date);
                const pos = getPositionInTimeline(date, quarters);

                // Alternate above/below based on index
                const isAbove = idx % 2 === 0;

                // Vary stem heights to avoid overlap
                const stemHeights = [50, 65, 80, 55, 70];
                const stemHeight = stemHeights[idx % stemHeights.length];

                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.style.left = `${pos}%`;

                const label = `${model.org} / ${model.model}`;

                let html = `
                    <div class="marker-dot"></div>
                    <div class="marker-stem ${isAbove ? 'above' : 'below'}" style="height: ${stemHeight}px;"></div>
                    <div class="marker-label ${isAbove ? 'above' : 'below'}" style="${isAbove ? 'bottom' : 'top'}: ${stemHeight + 8}px;">${label}</div>
                `;

                // Add comment if exists
                if (model.comment) {
                    // Check for nearby comments and stagger if needed
                    let commentTop = 180;
                    for (const [usedPos, row] of Object.entries(commentRows)) {
                        if (Math.abs(parseFloat(usedPos) - pos) < 8) {
                            commentTop = Math.max(commentTop, row + 65);
                        }
                    }
                    commentRows[pos] = commentTop;

                    html += `<div class="marker-comment" style="top: ${commentTop}px;">${model.comment}</div>`;
                }

                marker.innerHTML = html;
                container.appendChild(marker);
            });
        }

        // Load timeline on page load
        loadTimeline();
    </script>
</body>
</html>
