<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Timeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: white;
            padding: 20px;
        }

        .page-wrapper {
            padding: 20px 0;
        }

        /* Chart styles */
        .chart-container {
            position: relative;
            width: 100%;
            height: 250px;
            margin-bottom: 10px;
        }

        .chart-area {
            position: absolute;
            left: 1.5%;
            right: 1.5%;
            top: 30px;
            bottom: 30px;
            border-left: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
        }

        .chart-title {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }

        .y-axis-label {
            position: absolute;
            font-size: 9px;
            color: #666;
            left: 0;
            transform: translateX(-100%) translateX(-5px);
        }

        .y-grid-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed #eee;
        }

        .chart-legend {
            position: absolute;
            top: 5px;
            right: 50px;
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
        }

        .data-point {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }

        .data-point:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            z-index: 100;
        }

        .chart-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Timeline styles */
        .timeline-container {
            position: relative;
            width: 100%;
            height: 320px;
            margin: 0 auto;
        }

        .timeline-line {
            position: absolute;
            top: 100px;
            left: 1.5%;
            right: 1.5%;
            height: 2px;
            background: #333;
        }

        .quarter {
            position: absolute;
            top: 0;
            height: 100%;
        }

        .quarter-line {
            position: absolute;
            left: 0;
            top: 10px;
            bottom: 20px;
            border-left: 1px dashed #bbb;
        }

        .quarter-label {
            position: absolute;
            top: 115px;
            left: 0;
            transform: translateX(-50%);
            font-size: 11px;
            color: #333;
            white-space: nowrap;
        }

        .marker {
            position: absolute;
            top: 100px;
        }

        .marker-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
            left: -4px;
            top: -3px;
            z-index: 10;
        }

        .marker-stem {
            position: absolute;
            width: 1px;
            background: #333;
            left: 0;
        }

        .marker-stem.above {
            bottom: 5px;
        }

        .marker-stem.below {
            top: 5px;
        }

        .marker-label {
            position: absolute;
            font-size: 10px;
            color: #333;
            white-space: nowrap;
            transform: rotate(-45deg);
            transform-origin: bottom left;
        }

        .marker-label.above {
            left: 2px;
        }

        .marker-label.below {
            left: 2px;
            transform: rotate(45deg);
            transform-origin: top left;
        }

        .marker-comment {
            position: absolute;
            font-size: 9px;
            color: #555;
            max-width: 100px;
            line-height: 1.3;
            text-align: left;
            top: 110px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <div class="chart-container" id="chart">
            <div class="chart-title">Benchmark Scores Over Time</div>
            <div class="chart-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>MMLU (%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF5722;"></div>
                    <span>HLE (%)</span>
                </div>
            </div>
            <div class="chart-area" id="chartArea"></div>
        </div>
        <div class="timeline-container" id="timeline">
            <div class="timeline-line"></div>
        </div>
    </div>

    <script>
        // Parse CSV and build timeline
        async function loadTimeline() {
            const response = await fetch('models_benchmarks.csv');
            const csvText = await response.text();
            const lines = csvText.trim().split('\n');

            // Find column indices
            const headerRow = parseCSVLine(lines[0]);
            const modelIdx = headerRow.indexOf('Model');
            const orgIdx = headerRow.indexOf('Organisation');
            const dateIdx = headerRow.indexOf('Date');
            const mmluIdx = headerRow.indexOf('MMLU');
            const hleIdx = headerRow.indexOf('HLE');
            const commentsIdx = headerRow.indexOf('Comments');

            // Parse data rows
            const models = [];
            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (row.length > dateIdx) {
                    const dateStr = row[dateIdx];
                    if (dateStr && dateStr.match(/\d+\/\d+\/\d+/)) {
                        const comment = commentsIdx >= 0 && row.length > commentsIdx ? row[commentsIdx] : '';
                        const mmlu = parsePercentage(row[mmluIdx]);
                        const hle = parsePercentage(row[hleIdx]);
                        models.push({
                            model: row[modelIdx],
                            org: row[orgIdx],
                            date: dateStr,
                            comment: comment,
                            mmlu: mmlu,
                            hle: hle
                        });
                    }
                }
            }

            // Sort by date
            models.sort((a, b) => parseDate(a.date) - parseDate(b.date));

            // Calculate date range for quarters
            const dates = models.map(m => parseDate(m.date));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            // Generate quarters from min to max
            const quarters = generateQuarters(minDate, maxDate);

            // Render chart and timeline
            renderChart(quarters, models);
            renderTimeline(quarters, models);
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function parsePercentage(str) {
            if (!str) return null;
            const match = str.match(/~?(\d+\.?\d*)/);
            if (match) {
                return parseFloat(match[1]);
            }
            return null;
        }

        function parseDate(dateStr) {
            const parts = dateStr.split('/');
            const month = parseInt(parts[0]);
            const day = parseInt(parts[1]);
            let year = parseInt(parts[2]);
            if (year < 100) year += 2000;
            return new Date(year, month - 1, day);
        }

        function getQuarter(date) {
            const month = date.getMonth();
            const quarter = Math.floor(month / 3) + 1;
            return { q: quarter, year: date.getFullYear() };
        }

        function generateQuarters(minDate, maxDate) {
            const quarters = [];
            let current = new Date(minDate);
            current.setDate(1);
            current.setMonth(Math.floor(current.getMonth() / 3) * 3);

            while (current <= maxDate) {
                const q = getQuarter(current);
                quarters.push({
                    label: `Q${q.q} ${q.year}`,
                    year: q.year,
                    quarter: q.q,
                    startDate: new Date(current)
                });
                current.setMonth(current.getMonth() + 3);
            }

            // Add one more quarter at the end for spacing
            const q = getQuarter(current);
            quarters.push({
                label: `Q${q.q} ${q.year}`,
                year: q.year,
                quarter: q.q,
                startDate: new Date(current)
            });

            return quarters;
        }

        function getPositionInTimeline(date, quarters) {
            const totalQuarters = quarters.length;

            for (let i = 0; i < quarters.length - 1; i++) {
                const qStart = quarters[i].startDate;
                const qEnd = quarters[i + 1].startDate;

                if (date >= qStart && date < qEnd) {
                    const quarterDuration = qEnd - qStart;
                    const posInQuarter = (date - qStart) / quarterDuration;
                    const quarterWidth = 97 / totalQuarters;
                    const basePos = 1.9 + (i * quarterWidth);
                    return basePos + (posInQuarter * quarterWidth);
                }
            }

            const lastIdx = quarters.length - 1;
            const quarterWidth = 97 / totalQuarters;
            return 1.9 + (lastIdx * quarterWidth);
        }

        function renderChart(quarters, models) {
            const chartArea = document.getElementById('chartArea');
            const totalQuarters = quarters.length;
            const quarterWidth = 97 / totalQuarters;

            // Y-axis range - dynamically calculate from data
            const mmluValues = models.map(m => m.mmlu).filter(v => v !== null);
            const hleValues = models.map(m => m.hle).filter(v => v !== null);

            const mmluMin = Math.floor(Math.min(...mmluValues) / 10) * 10; // Round down to nearest 10
            const mmluMax = 100;
            const hleMin = 0;
            const hleMax = Math.ceil(Math.max(...hleValues) / 10) * 10; // Round up to nearest 10

            // Add Y-axis labels and grid lines for MMLU (left side)
            for (let v = mmluMin; v <= mmluMax; v += 10) {
                const yPercent = 100 - ((v - mmluMin) / (mmluMax - mmluMin)) * 100;

                const label = document.createElement('div');
                label.className = 'y-axis-label';
                label.style.bottom = `${100 - yPercent}%`;
                label.style.color = '#2196F3';
                label.textContent = `${v}%`;
                chartArea.appendChild(label);

                const gridLine = document.createElement('div');
                gridLine.className = 'y-grid-line';
                gridLine.style.bottom = `${100 - yPercent}%`;
                chartArea.appendChild(gridLine);
            }

            // Add Y-axis labels for HLE (right side)
            for (let v = hleMin; v <= hleMax; v += 10) {
                const yPercent = 100 - ((v - hleMin) / (hleMax - hleMin)) * 100;

                const label = document.createElement('div');
                label.className = 'y-axis-label';
                label.style.bottom = `${100 - yPercent}%`;
                label.style.right = '0';
                label.style.left = 'auto';
                label.style.transform = 'translateX(100%) translateX(5px)';
                label.style.color = '#FF5722';
                label.textContent = `${v}%`;
                chartArea.appendChild(label);
            }

            // Collect data points for lines
            const mmluPoints = [];
            const hlePoints = [];

            models.forEach((model) => {
                const date = parseDate(model.date);
                const xPos = getPositionInTimeline(date, quarters);
                // Convert from page percentage to chart area percentage
                const chartXPercent = ((xPos - 1.5) / 97) * 100;

                if (model.mmlu !== null) {
                    const yPercent = 100 - ((model.mmlu - mmluMin) / (mmluMax - mmluMin)) * 100;
                    mmluPoints.push({ x: chartXPercent, y: yPercent, model: model });

                    const point = document.createElement('div');
                    point.className = 'data-point';
                    point.style.left = `${chartXPercent}%`;
                    point.style.top = `${yPercent}%`;
                    point.style.background = '#2196F3';
                    point.setAttribute('data-tooltip', `${model.model}: ${model.mmlu}% MMLU`);
                    chartArea.appendChild(point);
                }

                if (model.hle !== null) {
                    const yPercent = 100 - ((model.hle - hleMin) / (hleMax - hleMin)) * 100;
                    hlePoints.push({ x: chartXPercent, y: yPercent, model: model });

                    const point = document.createElement('div');
                    point.className = 'data-point';
                    point.style.left = `${chartXPercent}%`;
                    point.style.top = `${yPercent}%`;
                    point.style.background = '#FF5722';
                    point.setAttribute('data-tooltip', `${model.model}: ${model.hle}% HLE`);
                    chartArea.appendChild(point);
                }
            });

            // Draw lines using SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'chart-line');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('preserveAspectRatio', 'none');

            // MMLU line
            if (mmluPoints.length > 1) {
                const mmluPath = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                const mmluPathData = mmluPoints.map(p => `${p.x},${p.y}`).join(' ');
                mmluPath.setAttribute('points', mmluPathData);
                mmluPath.setAttribute('fill', 'none');
                mmluPath.setAttribute('stroke', '#2196F3');
                mmluPath.setAttribute('stroke-width', '0.3');
                mmluPath.setAttribute('vector-effect', 'non-scaling-stroke');
                svg.appendChild(mmluPath);
            }

            // HLE line
            if (hlePoints.length > 1) {
                const hlePath = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                const hlePathData = hlePoints.map(p => `${p.x},${p.y}`).join(' ');
                hlePath.setAttribute('points', hlePathData);
                hlePath.setAttribute('fill', 'none');
                hlePath.setAttribute('stroke', '#FF5722');
                hlePath.setAttribute('stroke-width', '0.3');
                hlePath.setAttribute('vector-effect', 'non-scaling-stroke');
                svg.appendChild(hlePath);
            }

            chartArea.appendChild(svg);
        }

        function renderTimeline(quarters, models) {
            const container = document.getElementById('timeline');
            const totalQuarters = quarters.length;
            const quarterWidth = 97 / totalQuarters;

            // Render quarter markers
            quarters.forEach((q, i) => {
                const pos = 1.9 + (i * quarterWidth);
                const quarterDiv = document.createElement('div');
                quarterDiv.className = 'quarter';
                quarterDiv.style.left = `${pos}%`;
                quarterDiv.innerHTML = `
                    <div class="quarter-line"></div>
                    <div class="quarter-label">${q.label}</div>
                `;
                container.appendChild(quarterDiv);
            });

            // Track comment positions for collision detection
            const commentRows = {};

            // Render model markers
            models.forEach((model, idx) => {
                const date = parseDate(model.date);
                const pos = getPositionInTimeline(date, quarters);

                const isAbove = idx % 2 === 0;
                const stemHeightsAbove = [40, 50, 60, 45, 55];
                const stemHeightsBelow = [40, 50, 60, 45, 55];
                const stemHeight = isAbove
                    ? stemHeightsAbove[idx % stemHeightsAbove.length]
                    : stemHeightsBelow[idx % stemHeightsBelow.length];

                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.style.left = `${pos}%`;

                const label = `${model.org} / ${model.model}`;

                let html = `
                    <div class="marker-dot"></div>
                    <div class="marker-stem ${isAbove ? 'above' : 'below'}" style="height: ${stemHeight}px;"></div>
                    <div class="marker-label ${isAbove ? 'above' : 'below'}" style="${isAbove ? 'bottom' : 'top'}: ${stemHeight + 8}px;">${label}</div>
                `;

                if (model.comment) {
                    let commentTop = 130;
                    for (const [usedPos, row] of Object.entries(commentRows)) {
                        if (Math.abs(parseFloat(usedPos) - pos) < 8) {
                            commentTop = Math.max(commentTop, row + 65);
                        }
                    }
                    commentRows[pos] = commentTop;

                    html += `<div class="marker-comment" style="top: ${commentTop}px;">${model.comment}</div>`;
                }

                marker.innerHTML = html;
                container.appendChild(marker);
            });
        }

        // Load timeline on page load
        loadTimeline();
    </script>
</body>
</html>
